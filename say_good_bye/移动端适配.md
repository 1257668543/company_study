[TOC]

# Notice

 - 解决方案

    - ### Flexible

   - ### ViewPort

## 1. Flexible

### 1.1 REM

设置：

```javascript
// set 1rem = viewWidth / 10
function setRemUnit () {
    var rem = docEl.clientWidth / 10
    // docEl为document.documentElement，即html元素
    docEl.style.fontSize = rem + 'px'
}
setRemUnit();
```

### 1.2 DPR

#### 1.2.1 控制viewport的width和scale值适配高倍屏显示

设置`viewport`的`width`为`device-width`，改变浏览器`viewport`（布局视口和视觉视口）的默认宽度为理想视口宽度，从而使得用户可以在理想视口内看到完整的布局视口的内容。

等比设置`viewport`的`initial-scale`、`maximum-scale`、`minimum-scale`的值，从而实现`1物理像素=1css像素`，以适配高倍屏的显示效果（就是在这个地方规避了大家熟知的“1px问题”）

```javascript
var metaEL= doc.querySelector('meta[name="viewport"]');
var dpr = window.devicePixelRatio;
var scale = 1 / dpr
metaEl.setAttribute('content', 'width=device-width, initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no'); 
```

### 1.3  PostCSS-px2rem

配置在postcss.config.js

```json
plugins: {
    ...,
    'postcss-pxtorem': {
        // 750设计标准
        rootValue: 75,
        // 转换成的rem后，保留小数点后几位
        unitPrecision: 5,
        /**
        * 将会被转换的css属性列表，
        * 设置为*表示全部，['*','*position*','!letter-spacing','!font*']
        * *position* 表示所有包含 position 的属性
        * !letter-spacing 表示非 letter-spacing 属性
        * !font* 表示非font-size font-weight ... 等的属性
        * */
        propList: ['*', '!letter-spacing'],
        // 不会被转换的class选择器名，支持正则
        selectorBlackList: ['.rem-'],
        replace: true,
        // 允许在媒体查询中转换`px`
        mediaQuery: false,
        // 小于1px的将不会被转换
        minPixelValue: 1
    }
}
```

### 1.4 缺陷

##### 不兼容响应式布局！！

`@media`语法中涉及到的尺寸查询语句，查询的尺寸依据是当前设备的物理像素，和Flexible的布局理论（即针对不同`dpr`设备等比缩放视口的`scale`值，从而同时改变布局视口和视觉视口大小）相悖，因此响应式布局在“等比缩放视口大小”的情境下是无法正常工作的。



## 2. ViewPort scale



原理：通过设置initial-scale，将所有设备布局的窗口调整成为设计图的宽度 

```js
// 获取meta节点
var metaNode = document.querySelector('meta[name=viewport]');

// 定义设计稿宽度
var designWidth = 375;

// 计算当前屏幕的宽度与设计稿比例
var scale = document.documentElement.clientWidth/designWidth;

// 通过设置meta元素中content的initial-scale值达到移动端适配
meta.content = "initial-scale="+scale+",minimum-scale="+scale+",maximum-scale="+scale+",user-scalable=no";
```

## 3. ViewPort width



| unit   | relative to（参考单位）                                |
| ------ | ------------------------------------------------------ |
| 'vw'   | 1% of viewport's width（视觉视口宽度的1%）             |
| 'vh'   | 1% of viewport's height（视觉视口高度的1%）            |
| 'vmax' | 1% of viewport's larger dimension（vw和vh中的较大值）  |
| 'vmin' | 1% of viewport's smaller dimension（vw和vh中的较大值） |



![viewport](https://segmentfault.com/img/remote/1460000038159944/view)

### 3.1 核心思想

`vw`作为布局单位，从底层根本上解决了不同尺寸屏幕的适配问题，因为每个屏幕的百分比是固定的、可预测、可控制的。

从我们的实际开发工作出发，我们现在都是统一使用的`iPhone6`的视觉设计稿（即宽度为`750px`），那么`100vw=750px`，即`1vw = 7.5px`。那么如果设计稿上某一元素的宽度为`value`像素，那么其对应的vw值则可以通过`vw = value / 7.5`来计算得到。

需要注意的是，虽然`vw`无痛解决了我们之前遇到的很多问题，但是它并不是万能的，通过查找资料、博客和测试实践，以下场景我们可以放心使用vw来适配我们的页面：

• 容器适配，可以使用`vw`
• 文本适配，可以使用`vw`
• 大于`1px`的边框、圆角、阴影都可以使用`vw`
• 内边距和外边距都可以使用`vw`

### 3.2 postcss-px-to-viewport

`postcss-px-to-viewport`插件的作用和`postcss-pxtorem`的作用类似，主要用来把`px`单位转换为`vw`、`vh`、`vmin`或者`vmax`这样的视窗单位（推荐转换为`vw`，其他单位多多少少都有一些兼容性问题），也是viewport适配方案的核心插件之一。

结合`webpack`项目进行配置时，只需要将其配置在项目根目录下的`postcss.config.js`中即可，其基本配置项如下：

```json
plugins: {
'postcss-px-to-viewport': {
    unitToConvert: 'px',   // 需要转换的单位
    viewportWidth: 750,    // 视口宽度，等同于设计稿宽度
    unitPrecision: 5,      // 精确到小数点后几位
    /**
    * 将会被转换的css属性列表，
    * 设置为 * 表示全部，如：['*']
    * 在属性的前面或后面设置*，如：['*position*']，*position* 表示所有包含 position 的属性，如 background-position-y
    * 设置为 !xx 表示不匹配xx的那些属性，如：['!letter-spacing'] 表示除了letter-spacing 属性之外的其他属性
    * 还可以同时使用 ! 和 * ，如['!font*'] 表示除了font-size、 font-weight ...这些之外属性之外的其他属性名头部是‘font’的属性
    * */
    propList: ['*'],
    viewportUnit: 'vw',    // 需要转换成为的单位
    fontViewportUnit: 'vw',// 需要转换称为的字体单位
    /**
    * 需要忽略的选择器，即这些选择器对应的属性值不做单位转换
    * 设置为字符串，转换器在做转换时会忽略那些选择器中包含该字符串的选择器，如：['body']会匹配到 .body-class，也就意味着.body-class对应的样式设置不会被转换
    * 设置为正则表达式，在做转换前会先校验选择器是否匹配该正则，如果匹配，则不进行转换，如[/^body$/]会匹配到 body 但是不会匹配到 .body
    */
    selectorBlackList: [],
    minPixelValue: 1,      // 最小的像素单位值
    mediaQuery: false,     // 是否转换媒体查询中设置的属性值
    replace: true,                 // 替换包含vw的规则，而不是添加回退
    /**
    * 忽略一些文件，如'node_modules'
    * 设置为正则表达式，将会忽略匹配该正则的所有文件
    * 如果设置为数组，那么该数组内的元素都必须是正则表达式
    */
    exclude: [],
    landscape: false,      // 是否自动加入 @media (orientation: landscape)，其中的属性值是通过横屏宽度来转换的
    landscapeUnit: 'vw',   // 横屏单位
    landscapeWidth: 1334   // 横屏宽度
}
```

还可以在`selectorBlackList`选项中设置一些关键词或正则，来避免对这些指定的选择器做转换，如`selectorBlackList：['.ignore', '.hairlines']`：

```css
.ignore {
    margin: 10px;
    background-color: red;
}
.box {
    width: 180px;
    height: 300px;
}
.hairlines {
    border-bottom: 0.5px solid red;
}
```

转化之后：

```css
.box {
    width: 24vw;
    height: 40vw;
}
.ignore {
    margin: 10px; /*.box元素中带有.ignore类名，在这个类名写的`px`不会被转换*/
    background-color: red;
}
.hairlines {
    border-bottom: 0.5px solid red;
}
```
